<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
<!ENTITY % version-entities SYSTEM "version.entities">
%version-entities;
<!ENTITY % local.common.attrib "xmlns:xi  CDATA  #FIXED 'http://www.w3.org/2003/XInclude'">
<!ENTITY hash "#">
]>
<refentry id="GstAggregator">
<refmeta>
<refentrytitle role="top_of_page" id="GstAggregator.top_of_page">GstAggregator</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>GSTREAMER-LIBS Library</refmiscinfo>
</refmeta>
<refnamediv>
<refname>GstAggregator</refname>
<refpurpose>Base class for mixers and muxers, manages a set of input
pads and aggregates their streams</refpurpose>
</refnamediv>

<refsect1 id="GstAggregator.functions" role="functions_proto">
<title role="functions_proto.title">Functions</title>
<informaltable pgwide="1" frame="none">
<tgroup cols="2">
<colspec colname="functions_proto_type" colwidth="150px"/>
<colspec colname="functions_proto_name"/>
<tbody>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="GST-AGGREGATOR-SRC-PAD:CAPS">GST_AGGREGATOR_SRC_PAD</link><phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GstFlowReturn"><returnvalue>GstFlowReturn</returnvalue></link>
</entry><entry role="function_name"><link linkend="gst-aggregator-finish-buffer">gst_aggregator_finish_buffer</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="gst-aggregator-set-src-caps">gst_aggregator_set_src_caps</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GstClockTime"><returnvalue>GstClockTime</returnvalue></link>
</entry><entry role="function_name"><link linkend="gst-aggregator-get-latency">gst_aggregator_get_latency</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="gst-aggregator-set-latency">gst_aggregator_set_latency</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GstBufferPool"><returnvalue>GstBufferPool</returnvalue></link>&#160;*
</entry><entry role="function_name"><link linkend="gst-aggregator-get-buffer-pool">gst_aggregator_get_buffer_pool</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="void"><returnvalue>void</returnvalue></link>
</entry><entry role="function_name"><link linkend="gst-aggregator-get-allocator">gst_aggregator_get_allocator</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>
<row><entry role="function_type"><link linkend="GstClockTime"><returnvalue>GstClockTime</returnvalue></link>
</entry><entry role="function_name"><link linkend="gst-aggregator-simple-get-next-time">gst_aggregator_simple_get_next_time</link>&#160;<phrase role="c_punctuation">()</phrase></entry></row>

</tbody>
</tgroup>
</informaltable>
</refsect1>
<refsect1 id="GstAggregator.properties" role="properties">
<title role="properties.title">Properties</title>
<informaltable frame="none">
<tgroup cols="3">
<colspec colname="properties_type" colwidth="150px"/>
<colspec colname="properties_name" colwidth="300px"/>
<colspec colname="properties_flags" colwidth="200px"/>
<tbody>
<row><entry role="property_type"><link linkend="guint64"><type>guint64</type></link></entry><entry role="property_name"><link linkend="GstAggregator--latency">latency</link></entry><entry role="property_flags">Read / Write</entry></row>
<row><entry role="property_type"><link linkend="guint64"><type>guint64</type></link></entry><entry role="property_name"><link linkend="GstAggregator--min-upstream-latency">min-upstream-latency</link></entry><entry role="property_flags">Read / Write</entry></row>
<row><entry role="property_type"><link linkend="guint64"><type>guint64</type></link></entry><entry role="property_name"><link linkend="GstAggregator--start-time">start-time</link></entry><entry role="property_flags">Read / Write</entry></row>
<row><entry role="property_type"><link linkend="GstAggregatorStartTimeSelection"><type>GstAggregatorStartTimeSelection</type></link></entry><entry role="property_name"><link linkend="GstAggregator--start-time-selection">start-time-selection</link></entry><entry role="property_flags">Read / Write</entry></row>

</tbody>
</tgroup>
</informaltable>
</refsect1>
<refsect1 id="GstAggregator.other" role="other_proto">
<title role="other_proto.title">Types and Values</title>
<informaltable pgwide="1" frame="none">
<tgroup cols="2">
<colspec colname="other_proto_type" colwidth="150px"/>
<colspec colname="other_proto_name"/>
<tbody>
<row><entry role="datatype_keyword">struct</entry><entry role="function_name"><link linkend="GstAggregator-struct">GstAggregator</link></entry></row>
<row><entry role="datatype_keyword">struct</entry><entry role="function_name"><link linkend="GstAggregatorClass">GstAggregatorClass</link></entry></row>
<row><entry role="define_keyword">#define</entry><entry role="function_name"><link linkend="GST-AGGREGATOR-FLOW-NEED-DATA:CAPS">GST_AGGREGATOR_FLOW_NEED_DATA</link></entry></row>

</tbody>
</tgroup>
</informaltable>
</refsect1>
<refsect1 id="GstAggregator.object-hierarchy" role="object_hierarchy">
<title role="object_hierarchy.title">Object Hierarchy</title>
<screen>    <link linkend="GObject">GObject</link>
    <phrase role="lineart">&#9584;&#9472;&#9472;</phrase> <link linkend="GInitiallyUnowned">GInitiallyUnowned</link>
        <phrase role="lineart">&#9584;&#9472;&#9472;</phrase> <link linkend="GstObject">GstObject</link>
            <phrase role="lineart">&#9584;&#9472;&#9472;</phrase> <link linkend="GstElement">GstElement</link>
                <phrase role="lineart">&#9584;&#9472;&#9472;</phrase> GstAggregator
</screen>
</refsect1>

<refsect1 id="GstAggregator.includes"><title>Includes</title><synopsis>#include &lt;gst/base/base.h&gt;
</synopsis></refsect1>

<refsect1 id="GstAggregator.description" role="desc">
<title role="desc.title">Description</title>
<para>Manages a set of pads with the purpose of aggregating their buffers.
Control is given to the subclass when all pads have data.</para>
<itemizedlist>
<listitem>
<para>Base class for mixers and muxers. Subclasses should at least implement
the <link linkend="GstAggregatorClass.aggregate"><function>GstAggregatorClass.aggregate()</function></link> virtual method.</para>
</listitem>
<listitem>
<para>Installs a <link linkend="GstPadChainFunction"><type>GstPadChainFunction</type></link>, a <link linkend="GstPadEventFullFunction"><type>GstPadEventFullFunction</type></link> and a
<link linkend="GstPadQueryFunction"><type>GstPadQueryFunction</type></link> to queue all serialized data packets per sink pad.
Subclasses should not overwrite those, but instead implement
<link linkend="GstAggregatorClass.sink-event"><function>GstAggregatorClass.sink_event()</function></link> and <link linkend="GstAggregatorClass.sink-query"><function>GstAggregatorClass.sink_query()</function></link> as
needed.</para>
</listitem>
<listitem>
<para>When data is queued on all pads, the aggregate vmethod is called.</para>
</listitem>
<listitem>
<para>One can peek at the data on any given GstAggregatorPad with the
<link linkend="gst-aggregator-pad-peek-buffer"><function>gst_aggregator_pad_peek_buffer()</function></link> method, and remove it from the pad
with the <link linkend="gst-aggregator-pad-pop-buffer"><function>gst_aggregator_pad_pop_buffer()</function></link> method. When a buffer
has been taken with <link linkend="pop-buffer"><function>pop_buffer()</function></link>, a new buffer can be queued
on that pad.</para>
</listitem>
<listitem>
<para>If the subclass wishes to push a buffer downstream in its aggregate
implementation, it should do so through the
<link linkend="gst-aggregator-finish-buffer"><function>gst_aggregator_finish_buffer()</function></link> method. This method will take care
of sending and ordering mandatory events such as stream start, caps
and segment.</para>
</listitem>
<listitem>
<para>Same goes for EOS events, which should not be pushed directly by the
subclass, it should instead return GST_FLOW_EOS in its aggregate
implementation.</para>
</listitem>
<listitem>
<para>Note that the aggregator logic regarding gap event handling is to turn
these into gap buffers with matching PTS and duration. It will also
flag these buffers with GST_BUFFER_FLAG_GAP and GST_BUFFER_FLAG_DROPPABLE
to ease their identification and subsequent processing.</para>
</listitem>
<listitem>
<para>Subclasses must use (a subclass of) <link linkend="GstAggregatorPad"><type>GstAggregatorPad</type></link> for both their
sink and source pads.
See <link linkend="gst-element-class-add-static-pad-template-with-gtype"><function>gst_element_class_add_static_pad_template_with_gtype()</function></link>.</para>
</listitem>
</itemizedlist>
<para>This class used to live in gst-plugins-bad and was moved to core.</para>

</refsect1>
<refsect1 id="GstAggregator.functions_details" role="details">
<title role="details.title">Functions</title>
<refsect2 id="GST-AGGREGATOR-SRC-PAD:CAPS" role="macro" condition="since:1.6">
<title>GST_AGGREGATOR_SRC_PAD()</title>
<indexterm zone="GST-AGGREGATOR-SRC-PAD:CAPS" role="1.6"><primary>GST_AGGREGATOR_SRC_PAD</primary></indexterm>
<programlisting language="C">#define GST_AGGREGATOR_SRC_PAD(agg) (((GstAggregator *)(agg))-&gt;srcpad)
</programlisting>
<para>Convenience macro to access the source pad of <link linkend="GstAggregator"><type>GstAggregator</type></link></para>
<refsect3 id="GST-AGGREGATOR-SRC-PAD.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>agg</para></entry>
<entry role="parameter_description"><para>a <link linkend="GstAggregator"><type>GstAggregator</type></link></para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><para role="since">Since: <link linkend="api-index-1.6">1.6</link></para></refsect2>
<refsect2 id="gst-aggregator-finish-buffer" role="function">
<title>gst_aggregator_finish_buffer&#160;()</title>
<indexterm zone="gst-aggregator-finish-buffer"><primary>gst_aggregator_finish_buffer</primary></indexterm>
<programlisting language="C"><link linkend="GstFlowReturn"><returnvalue>GstFlowReturn</returnvalue></link>
gst_aggregator_finish_buffer (<parameter><link linkend="GstAggregator"><type>GstAggregator</type></link> *aggregator</parameter>,
                              <parameter><link linkend="GstBuffer"><type>GstBuffer</type></link> *buffer</parameter>);</programlisting>
<para>This method will push the provided output buffer downstream. If needed,
mandatory events such as stream-start, caps, and segment events will be
sent before pushing the buffer.</para>
<refsect3 id="gst-aggregator-finish-buffer.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>aggregator</para></entry>
<entry role="parameter_description"><para>The <link linkend="GstAggregator"><type>GstAggregator</type></link></para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>buffer</para></entry>
<entry role="parameter_description"><para>the <link linkend="GstBuffer"><type>GstBuffer</type></link> to push. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>transfer full</acronym>]</emphasis></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="gst-aggregator-set-src-caps" role="function">
<title>gst_aggregator_set_src_caps&#160;()</title>
<indexterm zone="gst-aggregator-set-src-caps"><primary>gst_aggregator_set_src_caps</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
gst_aggregator_set_src_caps (<parameter><link linkend="GstAggregator"><type>GstAggregator</type></link> *self</parameter>,
                             <parameter><link linkend="GstCaps"><type>GstCaps</type></link> *caps</parameter>);</programlisting>
<para>Sets the caps to be used on the src pad.</para>
<refsect3 id="gst-aggregator-set-src-caps.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>self</para></entry>
<entry role="parameter_description"><para>The <link linkend="GstAggregator"><type>GstAggregator</type></link></para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>caps</para></entry>
<entry role="parameter_description"><para>The <link linkend="GstCaps"><type>GstCaps</type></link> to set on the src pad.</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="gst-aggregator-get-latency" role="function">
<title>gst_aggregator_get_latency&#160;()</title>
<indexterm zone="gst-aggregator-get-latency"><primary>gst_aggregator_get_latency</primary></indexterm>
<programlisting language="C"><link linkend="GstClockTime"><returnvalue>GstClockTime</returnvalue></link>
gst_aggregator_get_latency (<parameter><link linkend="GstAggregator"><type>GstAggregator</type></link> *self</parameter>);</programlisting>
<para>Retrieves the latency values reported by <parameter>self</parameter>
 in response to the latency
query, or <link linkend="GST-CLOCK-TIME-NONE:CAPS"><literal>GST_CLOCK_TIME_NONE</literal></link> if there is not live source connected and the element
will not wait for the clock.</para>
<para>Typically only called by subclasses.</para>
<refsect3 id="gst-aggregator-get-latency.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>self</para></entry>
<entry role="parameter_description"><para>a <link linkend="GstAggregator"><type>GstAggregator</type></link></para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="gst-aggregator-get-latency.returns" role="returns">
<title>Returns</title>
<para> The latency or <link linkend="GST-CLOCK-TIME-NONE:CAPS"><literal>GST_CLOCK_TIME_NONE</literal></link> if the element does not sync</para>
</refsect3></refsect2>
<refsect2 id="gst-aggregator-set-latency" role="function">
<title>gst_aggregator_set_latency&#160;()</title>
<indexterm zone="gst-aggregator-set-latency"><primary>gst_aggregator_set_latency</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
gst_aggregator_set_latency (<parameter><link linkend="GstAggregator"><type>GstAggregator</type></link> *self</parameter>,
                            <parameter><link linkend="GstClockTime"><type>GstClockTime</type></link> min_latency</parameter>,
                            <parameter><link linkend="GstClockTime"><type>GstClockTime</type></link> max_latency</parameter>);</programlisting>
<para>Lets <link linkend="GstAggregator"><type>GstAggregator</type></link> sub-classes tell the baseclass what their internal
latency is. Will also post a LATENCY message on the bus so the pipeline
can reconfigure its global latency.</para>
<refsect3 id="gst-aggregator-set-latency.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>self</para></entry>
<entry role="parameter_description"><para>a <link linkend="GstAggregator"><type>GstAggregator</type></link></para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>min_latency</para></entry>
<entry role="parameter_description"><para>minimum latency</para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>max_latency</para></entry>
<entry role="parameter_description"><para>maximum latency</para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="gst-aggregator-get-buffer-pool" role="function">
<title>gst_aggregator_get_buffer_pool&#160;()</title>
<indexterm zone="gst-aggregator-get-buffer-pool"><primary>gst_aggregator_get_buffer_pool</primary></indexterm>
<programlisting language="C"><link linkend="GstBufferPool"><returnvalue>GstBufferPool</returnvalue></link>&#160;*
gst_aggregator_get_buffer_pool (<parameter><link linkend="GstAggregator"><type>GstAggregator</type></link> *self</parameter>);</programlisting>
<refsect3 id="gst-aggregator-get-buffer-pool.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>self</para></entry>
<entry role="parameter_description"><para>a <link linkend="GstAggregator"><type>GstAggregator</type></link></para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="gst-aggregator-get-buffer-pool.returns" role="returns">
<title>Returns</title>
<para>the instance of the <link linkend="GstBufferPool"><type>GstBufferPool</type></link> used
by <parameter>trans</parameter>
; free it after use it. </para>
<para><emphasis role="annotation">[<acronym>transfer full</acronym>]</emphasis></para>
</refsect3></refsect2>
<refsect2 id="gst-aggregator-get-allocator" role="function">
<title>gst_aggregator_get_allocator&#160;()</title>
<indexterm zone="gst-aggregator-get-allocator"><primary>gst_aggregator_get_allocator</primary></indexterm>
<programlisting language="C"><link linkend="void"><returnvalue>void</returnvalue></link>
gst_aggregator_get_allocator (<parameter><link linkend="GstAggregator"><type>GstAggregator</type></link> *self</parameter>,
                              <parameter><link linkend="GstAllocator"><type>GstAllocator</type></link> **allocator</parameter>,
                              <parameter><link linkend="GstAllocationParams"><type>GstAllocationParams</type></link> *params</parameter>);</programlisting>
<para>Lets <link linkend="GstAggregator"><type>GstAggregator</type></link> sub-classes get the memory <parameter>allocator</parameter>

acquired by the base class and its <parameter>params</parameter>
.</para>
<para>Unref the <parameter>allocator</parameter>
 after use it.</para>
<refsect3 id="gst-aggregator-get-allocator.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>self</para></entry>
<entry role="parameter_description"><para>a <link linkend="GstAggregator"><type>GstAggregator</type></link></para></entry>
<entry role="parameter_annotations"></entry></row>
<row><entry role="parameter_name"><para>allocator</para></entry>
<entry role="parameter_description"><para>the <link linkend="GstAllocator"><type>GstAllocator</type></link>
used. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>out</acronym>][<acronym>allow-none</acronym>][<acronym>transfer full</acronym>]</emphasis></entry></row>
<row><entry role="parameter_name"><para>params</para></entry>
<entry role="parameter_description"><para>the
<link linkend="GstAllocationParams"><type>GstAllocationParams</type></link> of <parameter>allocator</parameter>
. </para></entry>
<entry role="parameter_annotations"><emphasis role="annotation">[<acronym>out</acronym>][<acronym>allow-none</acronym>][<acronym>transfer full</acronym>]</emphasis></entry></row>
</tbody></tgroup></informaltable>
</refsect3></refsect2>
<refsect2 id="gst-aggregator-simple-get-next-time" role="function" condition="since:1.16">
<title>gst_aggregator_simple_get_next_time&#160;()</title>
<indexterm zone="gst-aggregator-simple-get-next-time" role="1.16"><primary>gst_aggregator_simple_get_next_time</primary></indexterm>
<programlisting language="C"><link linkend="GstClockTime"><returnvalue>GstClockTime</returnvalue></link>
gst_aggregator_simple_get_next_time (<parameter><link linkend="GstAggregator"><type>GstAggregator</type></link> *self</parameter>);</programlisting>
<para>This is a simple <link linkend="GstAggregator-get-next-time"><type>“get_next_time”</type></link> implementation that
just looks at the <link linkend="GstSegment"><type>GstSegment</type></link> on the srcpad of the aggregator and bases
the next time on the running time there.</para>
<para>This is the desired behaviour in most cases where you have a live source
and you have a dead line based aggregator subclass.</para>
<refsect3 id="gst-aggregator-simple-get-next-time.parameters" role="parameters">
<title>Parameters</title>
<informaltable role="parameters_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="parameters_name" colwidth="150px"/>
<colspec colname="parameters_description"/>
<colspec colname="parameters_annotations" colwidth="200px"/>
<tbody>
<row><entry role="parameter_name"><para>self</para></entry>
<entry role="parameter_description"><para>A <link linkend="GstAggregator"><type>GstAggregator</type></link></para></entry>
<entry role="parameter_annotations"></entry></row>
</tbody></tgroup></informaltable>
</refsect3><refsect3 id="gst-aggregator-simple-get-next-time.returns" role="returns">
<title>Returns</title>
<para> The running time based on the position</para>
</refsect3><para role="since">Since: <link linkend="api-index-1.16">1.16</link></para></refsect2>

</refsect1>
<refsect1 id="GstAggregator.other_details" role="details">
<title role="details.title">Types and Values</title>
<refsect2 id="GstAggregator-struct" role="struct">
<title>struct GstAggregator</title>
<indexterm zone="GstAggregator-struct" role="1.14"><primary>GstAggregator</primary></indexterm>
<programlisting language="C">struct GstAggregator {
  GstPad                *  srcpad;
};
</programlisting>
<para>Aggregator base class object structure.</para>
<refsect3 id="GstAggregator.members" role="struct_members">
<title>Members</title>
<informaltable role="struct_members_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="struct_members_name" colwidth="300px"/>
<colspec colname="struct_members_description"/>
<colspec colname="struct_members_annotations" colwidth="200px"/>
<tbody>
<row role="member"><entry role="struct_member_name"><para><link linkend="GstPad"><type>GstPad</type></link>&#160;*<structfield id="GstAggregator-struct.srcpad">srcpad</structfield>;</para></entry>
<entry role="struct_member_description"><para>the aggregator's source pad</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
</tbody></tgroup></informaltable>
</refsect3>
<para role="since">Since: <link linkend="api-index-1.14">1.14</link></para></refsect2>
<refsect2 id="GstAggregatorClass" role="struct" condition="since:1.14">
<title>struct GstAggregatorClass</title>
<indexterm zone="GstAggregatorClass" role="1.14"><primary>GstAggregatorClass</primary></indexterm>
<programlisting language="C">struct GstAggregatorClass {
  GstElementClass   parent_class;

  GstFlowReturn     (*flush)          (GstAggregator    *  aggregator);

  GstBuffer *       (*clip)           (GstAggregator    *  aggregator,
                                       GstAggregatorPad *  aggregator_pad,
                                       GstBuffer        *  buf);

  GstFlowReturn     (*finish_buffer)  (GstAggregator    * aggregator,
                                       GstBuffer        * buffer);

  /* sinkpads virtual methods */
  gboolean          (*sink_event)     (GstAggregator    *  aggregator,
                                       GstAggregatorPad *  aggregator_pad,
                                       GstEvent         *  event);

  gboolean          (*sink_query)     (GstAggregator    *  aggregator,
                                       GstAggregatorPad *  aggregator_pad,
                                       GstQuery         *  query);

  /* srcpad virtual methods */
  gboolean          (*src_event)      (GstAggregator    *  aggregator,
                                       GstEvent         *  event);

  gboolean          (*src_query)      (GstAggregator    *  aggregator,
                                       GstQuery         *  query);

  gboolean          (*src_activate)   (GstAggregator    *  aggregator,
                                       GstPadMode          mode,
                                       gboolean            active);

  GstFlowReturn     (*aggregate)      (GstAggregator    *  aggregator,
                                       gboolean            timeout);

  gboolean          (*stop)           (GstAggregator    *  aggregator);

  gboolean          (*start)          (GstAggregator    *  aggregator);

  GstClockTime      (*get_next_time)  (GstAggregator    *  aggregator);

  GstAggregatorPad * (*create_new_pad) (GstAggregator  * self,
                                        GstPadTemplate * templ,
                                        const gchar    * req_name,
                                        const GstCaps  * caps);

  /**
   * GstAggregatorClass::update_src_caps:
   * @ret: (out) (allow-none):
   */
  GstFlowReturn     (*update_src_caps) (GstAggregator *  self,
                                        GstCaps       *  caps,
                                        GstCaps       ** ret);
  GstCaps *         (*fixate_src_caps) (GstAggregator *  self,
                                        GstCaps       *  caps);
  gboolean          (*negotiated_src_caps) (GstAggregator *  self,
                                            GstCaps      *  caps);
  gboolean          (*decide_allocation) (GstAggregator * self,
                                          GstQuery * query);
  gboolean          (*propose_allocation) (GstAggregator * self,
                                           GstAggregatorPad * pad,
                                           GstQuery * decide_query,
                                           GstQuery * query);
};
</programlisting>
<para>The aggregator base class will handle in a thread-safe way all manners of
concurrent flushes, seeks, pad additions and removals, leaving to the
subclass the responsibility of clipping buffers, and aggregating buffers in
the way the implementor sees fit.</para>
<para>It will also take care of event ordering (stream-start, segment, eos).</para>
<para>Basically, a simple implementation will override <parameter>aggregate</parameter>
, and call
_finish_buffer from inside that function.</para>
<refsect3 id="GstAggregatorClass.members" role="struct_members">
<title>Members</title>
<informaltable role="struct_members_table" pgwide="1" frame="none">
<tgroup cols="3">
<colspec colname="struct_members_name" colwidth="300px"/>
<colspec colname="struct_members_description"/>
<colspec colname="struct_members_annotations" colwidth="200px"/>
<tbody>
<row role="member"><entry role="struct_member_name"><para><structfield id="GstAggregatorClass.flush">flush</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>Optional.
Called after a successful flushing seek, once all the flush
stops have been received. Flush pad-specific data in
<link linkend="GstAggregatorPad"><type>GstAggregatorPad</type></link>->flush.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GstAggregatorClass.clip">clip</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>Optional.
Called when a buffer is received on a sink pad, the task of
clipping it and translating it to the current segment falls
on the subclass. The function should use the segment of data
and the negotiated media type on the pad to perform
clipping of input buffer. This function takes ownership of
buf and should output a buffer or return NULL in
if the buffer should be dropped.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GstAggregatorClass.finish-buffer">finish_buffer</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>Optional.
Called when a subclass calls <link linkend="gst-aggregator-finish-buffer"><function>gst_aggregator_finish_buffer()</function></link>
from their aggregate function to push out a buffer.
Subclasses can override this to modify or decorate buffers
before they get pushed out. This function takes ownership
of the buffer passed. Subclasses that override this method
should always chain up to the parent class virtual method.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GstAggregatorClass.sink-event">sink_event</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>Optional.
Called when an event is received on a sink pad, the subclass
should always chain up.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GstAggregatorClass.sink-query">sink_query</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>Optional.
Called when a query is received on a sink pad, the subclass
should always chain up.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GstAggregatorClass.src-event">src_event</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>Optional.
Called when an event is received on the src pad, the subclass
should always chain up.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GstAggregatorClass.src-query">src_query</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>Optional.
Called when a query is received on the src pad, the subclass
should always chain up.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GstAggregatorClass.src-activate">src_activate</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>Optional.
Called when the src pad is activated, it will start/stop its
pad task right after that call.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GstAggregatorClass.aggregate">aggregate</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>Mandatory.
Called when buffers are queued on all sinkpads. Classes
should iterate the GstElement->sinkpads and peek or steal
buffers from the <link linkend="GstAggregatorPads"><type>GstAggregatorPads</type></link>. If the subclass returns
GST_FLOW_EOS, sending of the eos event will be taken care
of. Once / if a buffer has been constructed from the
aggregated buffers, the subclass should call _finish_buffer.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GstAggregatorClass.stop">stop</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>Optional.
Called when the element goes from PAUSED to READY.
The subclass should free all resources and reset its state.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GstAggregatorClass.start">start</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>Optional.
Called when the element goes from READY to PAUSED.
The subclass should get ready to process
aggregated buffers.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GstAggregatorClass.get-next-time">get_next_time</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>Optional.
Called when the element needs to know the running time of the next
rendered buffer for live pipelines. This causes deadline
based aggregation to occur. Defaults to returning
GST_CLOCK_TIME_NONE causing the element to wait for buffers
on all sink pads before aggregating.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GstAggregatorClass.create-new-pad">create_new_pad</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>Optional.
Called when a new pad needs to be created. Allows subclass that
don't have a single sink pad template to provide a pad based
on the provided information.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GstAggregatorClass.update-src-caps">update_src_caps</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>Lets subclasses update the <link linkend="GstCaps"><type>GstCaps</type></link> representing
the src pad caps before usage.  The result should end up
in <parameter>ret</parameter>
. Return <link linkend="GST-AGGREGATOR-FLOW-NEED-DATA:CAPS"><literal>GST_AGGREGATOR_FLOW_NEED_DATA</literal></link> to indicate that the
element needs more information (caps, a buffer, etc) to
choose the correct caps. Should return ANY caps if the
stream has not caps at all.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GstAggregatorClass.fixate-src-caps">fixate_src_caps</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>Optional.
Fixate and return the src pad caps provided.  The function takes
ownership of <parameter>caps</parameter>
and returns a fixated version of
<parameter>caps</parameter>
. <parameter>caps</parameter>
is not guaranteed to be writable.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GstAggregatorClass.negotiated-src-caps">negotiated_src_caps</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>Optional.
Notifies subclasses what caps format has been negotiated</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GstAggregatorClass.decide-allocation">decide_allocation</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>Optional.
Allows the subclass to influence the allocation choices.
Setup the allocation parameters for allocating output
buffers. The passed in query contains the result of the
downstream allocation query.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
<row role="member"><entry role="struct_member_name"><para><structfield id="GstAggregatorClass.propose-allocation">propose_allocation</structfield>&#160;()</para></entry>
<entry role="struct_member_description"><para>Optional.
Allows the subclass to handle the allocation query from upstream.</para></entry>
<entry role="struct_member_annotations"></entry>
</row>
</tbody></tgroup></informaltable>
</refsect3>
<para role="since">Since: <link linkend="api-index-1.14">1.14</link></para></refsect2>
<refsect2 id="GST-AGGREGATOR-FLOW-NEED-DATA:CAPS" role="macro">
<title>GST_AGGREGATOR_FLOW_NEED_DATA</title>
<indexterm zone="GST-AGGREGATOR-FLOW-NEED-DATA:CAPS"><primary>GST_AGGREGATOR_FLOW_NEED_DATA</primary></indexterm>
<programlisting language="C">#define GST_AGGREGATOR_FLOW_NEED_DATA             GST_FLOW_CUSTOM_ERROR
</programlisting>
</refsect2>

</refsect1>
<refsect1 id="GstAggregator.property-details" role="property_details">
<title role="property_details.title">Property Details</title>
<refsect2 id="GstAggregator--latency" role="property"><title>The <literal>“latency”</literal> property</title>
<indexterm zone="GstAggregator--latency"><primary>GstAggregator:latency</primary></indexterm>
<programlisting>  “latency”                  <link linkend="guint64"><type>guint64</type></link></programlisting>
<para>Additional latency in live mode to allow upstream to take longer to produce buffers for the current position (in nanoseconds).</para><para>Owner: GstAggregator</para>
<para>Flags: Read / Write</para>
<para>Default value: 0</para>
</refsect2>
<refsect2 id="GstAggregator--min-upstream-latency" role="property"><title>The <literal>“min-upstream-latency”</literal> property</title>
<indexterm zone="GstAggregator--min-upstream-latency" role="1.16"><primary>GstAggregator:min-upstream-latency</primary></indexterm>
<programlisting>  “min-upstream-latency”     <link linkend="guint64"><type>guint64</type></link></programlisting>
<para>Force minimum upstream latency (in nanoseconds). When sources with a
higher latency are expected to be plugged in dynamically after the
aggregator has started playing, this allows overriding the minimum
latency reported by the initial source(s). This is only taken into
account when larger than the actually reported minimum latency.</para>
<para>Owner: GstAggregator</para>
<para>Flags: Read / Write</para>
<para>Default value: 0</para>
<para role="since">Since: <link linkend="api-index-1.16">1.16</link></para></refsect2>
<refsect2 id="GstAggregator--start-time" role="property"><title>The <literal>“start-time”</literal> property</title>
<indexterm zone="GstAggregator--start-time"><primary>GstAggregator:start-time</primary></indexterm>
<programlisting>  “start-time”               <link linkend="guint64"><type>guint64</type></link></programlisting>
<para>Start time to use if start-time-selection=set.</para><para>Owner: GstAggregator</para>
<para>Flags: Read / Write</para>
<para>Default value: 18446744073709551615</para>
</refsect2>
<refsect2 id="GstAggregator--start-time-selection" role="property"><title>The <literal>“start-time-selection”</literal> property</title>
<indexterm zone="GstAggregator--start-time-selection"><primary>GstAggregator:start-time-selection</primary></indexterm>
<programlisting>  “start-time-selection”     <link linkend="GstAggregatorStartTimeSelection"><type>GstAggregatorStartTimeSelection</type></link></programlisting>
<para>Decides which start time is output.</para><para>Owner: GstAggregator</para>
<para>Flags: Read / Write</para>
<para>Default value: Start at 0 running time (default)</para>
</refsect2>

</refsect1>
<refsect1 id="GstAggregator.see-also">
<title>See Also</title>
<para>gstcollectpads for historical reasons.</para>

</refsect1>

</refentry>
